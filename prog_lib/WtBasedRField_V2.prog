// ta_Dump File v3.0 -- code v7.0.4.0 rev7949
Program .projects[0].programs[0] { 
 ProgObjList @.objs = [3] {
  DataTable @[0] { 
   DataTableCols @.data = [2] {
    float_Data @[0] { };
    int_Data @[1] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };
  };
  WtBasedRF @[1] { };
  DataTable @[2] { 
   DataTableCols @.data = [1] {
    float_Data @[0] { };
   };
  };
 };

 ProgType_List @.types = [0] {
 };

 ProgVar_List @.args = [0] {
 };

 ProgVar_List @.vars = [8] {
  ProgVar @[0] { };
  ProgVar @[1] { };
  ProgVar @[2] { };
  ProgVar @[3] { };
  ProgVar @[4] { };
  ProgVar @[5] { };
  ProgVar @[6] { };
  ProgVar @[7] { };
 };

 Function_List @.functions = [0] {
 };

 ProgEl_List @.init_code = [1] {
  LocalVars @[0] { 
   ProgVar_List @.local_vars = [0] {
   };
  };
 };

 ProgEl_List @.prog_code = [2] {
  LocalVars @[0] { 
   ProgVar_List @.local_vars = [0] {
   };
  };
  MethodCall @[1] { 
   ProgArg_List @.meth_args = [7] {
    ProgArg @[0] { };
    ProgArg @[1] { };
    ProgArg @[2] { };
    ProgArg @[3] { };
    ProgArg @[4] { };
    ProgArg @[5] { };
    ProgArg @[6] { };
   };
  };
 };
};
Program .projects[0].programs[0] {
 name="WtBasedRField_V2";
 short_nm="WBsRFl";
 tags="Statistic, Receptive Field";
 desc="computes a weight based receptive field (RF) using WtBasedRF object type --  The calculation is based on the V2 wts that are developed during training in combination with the gabor filter values that are applied to the original image. Each row of the WtRFData table shows a single units' representation field and how the original image looks to that unit. Note - V2 may receive from mulitple layers, choose one";
 flags=NO_STOP_STEP;
 objs {
  name="objs";
  el_typ=ActBasedRF;
  el_def=0;
  DataTable @[0] {
   name="WtRFData";
   desc="receptive field data -- could move this into AnalysisData if you want..";
   data {
    name="data";
    el_typ=float_Data;
    el_def=0;
    float_Data @[0] {
     name="values";
     col_flags=SAVE_ROWS|SAVE_DATA;
     is_matrix=1;
     cell_geom{ 24;24;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [2] ;;     };
     width=0;
    };
    int_Data @[1] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_769";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="count";
     col_flags=SAVE_ROWS|SAVE_DATA;
     is_matrix=1;
     cell_geom{ 24;24;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [2] ;;     };
     width=0;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [0]    };
  };
  WtBasedRF @[1] {
   name="WtBasedRF_Analysis";
   network=NULL;
   trg_layer=NULL;
   snd_layer=NULL;
   dt_trg_rf=.projects[0].programs[0].objs[0]$$;
   dt_snd_rf=NULL;
   trg_wt_threshold=0;
  };
  DataTable @[2] {
   name="trg_layer_wts";
   desc=;
   data {
    name="data";
    el_typ=float_Data;
    el_def=0;
    float_Data @[0] {
     name="V1h_l";
     col_flags=SAVE_ROWS|SAVE_DATA;
     is_matrix=1;
     cell_geom{ 4;2;4;4;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [4] ;;;;     };
     width=0;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [0]    };
  };
 };
 types {
  name="types";
  el_typ=DynEnumType;
  el_def=0;
 };
 args {
  name="args";
  el_typ=ProgVar;
  el_def=0;
 };
 vars {
  name="vars";
  el_typ=ProgVar;
  el_def=0;
  ProgVar @[0] {
   name="network";
   var_type=T_Object;
   object_type=LeabraNetwork;
   object_val=NULL;
   objs_ptr=0;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[1] {
   name="WtBasedRF_Analysis";
   var_type=T_Object;
   object_type=WtBasedRF;
   object_val=.projects[0].programs[0].objs[1]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc="This is the object on which to call the compute method";
   init_from=NULL;
  };
  ProgVar @[2] {
   name="WtRFData";
   var_type=T_Object;
   object_type=DataTable;
   object_val=$.projects[0].programs[0].objs[0]$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc="data table to record weight based receptive field values - the columns and rows will be generated by the underlying code";
   init_from=NULL;
  };
  ProgVar @[3] {
   name="trg_layer_wts";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs[0].objs[2]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc="these are the weights for each projection to each unit of the target layer";
   init_from=NULL;
  };
  ProgVar @[4] {
   name="trg_layer";
   var_type=T_Object;
   object_type=LeabraLayer;
   object_val=NULL;
   objs_ptr=0;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc="layer for which to generate the receptive field data - typically V2 but could be any layer receiving directly from a V1 layer";
   init_from=NULL;
  };
  ProgVar @[5] {
   name="snd_layer";
   var_type=T_Object;
   object_type=LeabraLayer;
   object_val=NULL;
   objs_ptr=0;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc="the layer sending to target layer - if more than one, choose";
   init_from=NULL;
  };
  ProgVar @[6] {
   name="v1_retina_proc";
   var_type=T_Object;
   object_type=V1RetinaProc;
   object_val=NULL;
   objs_ptr=0;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc="this is the retina_proc which specifies the gabor filters used in training - can be found in ApplyInputs";
   init_from=NULL;
  };
  ProgVar @[7] {
   name="wt_threshold";
   var_type=T_Real;
   real_val=0;
   objs_ptr=0;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
 };
 functions {
  name="functions";
  el_typ=Function;
  el_def=0;
 };
 init_code {
  name="init_code";
  el_typ=ProgCode;
  el_def=0;
  LocalVars @[0] {
   desc=;
   flags=0;
   orig_prog_code=;
   local_vars {
    name="local_vars";
    el_typ=ProgVar;
    el_def=0;
   };
  };
 };
 prog_code {
  name="prog_code";
  el_typ=ProgCode;
  el_def=0;
  LocalVars @[0] {
   desc=;
   flags=0;
   orig_prog_code=;
   local_vars {
    name="local_vars";
    el_typ=ProgVar;
    el_def=0;
   };
  };
  MethodCall @[1] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   orig_prog_code="WtBasedRF_0->ComputeRF()";
   result_var=NULL;
   obj=.projects[0].programs[0].vars[1]$$;
   method=WtBasedRF::ComputeV2RF;
   meth_args {
    name="meth_args";
    el_typ=ProgArg;
    el_def=0;
    ProgArg @[0] {
     arg_type=Network_ptr;
     type="Network*";
     name="net";
     required=1;
     def_val=;
     prev_expr="network";
     expr {
      expr="network";
     };
    };
    ProgArg @[1] {
     arg_type=DataTable_ptr;
     type="DataTable*";
     name="dt_trg";
     required=1;
     def_val=;
     prev_expr="WtRFData";
     expr {
      expr="WtRFData";
     };
    };
    ProgArg @[2] {
     arg_type=DataTable_ptr;
     type="DataTable*";
     name="wts";
     required=1;
     def_val=;
     prev_expr="trg_layer_wts";
     expr {
      expr="trg_layer_wts";
     };
    };
    ProgArg @[3] {
     arg_type=Layer_ptr;
     type="Layer*";
     name="tlay";
     required=1;
     def_val=;
     prev_expr="trg_layer";
     expr {
      expr="trg_layer";
     };
    };
    ProgArg @[4] {
     arg_type=Layer_ptr;
     type="Layer*";
     name="slay";
     required=1;
     def_val=;
     prev_expr="snd_layer";
     expr {
      expr="snd_layer";
     };
    };
    ProgArg @[5] {
     arg_type=V1RetinaProc_ptr;
     type="V1RetinaProc*";
     name="rproc";
     required=1;
     def_val=;
     prev_expr="v1_retina_proc";
     expr {
      expr="v1_retina_proc";
     };
    };
    ProgArg @[6] {
     arg_type=float;
     type="float";
     name="wt_threshold";
     required=0;
     def_val="0";
     prev_expr=;
     expr {
      expr="wt_threshold";
     };
    };
   };
   meth_sig="bool ComputeV2RF(Network* net, DataTable* dt_trg, DataTable* wts, Layer* tlay, Layer* slay, V1RetinaProc* rproc, float wt_threshold = 0)";
   meth_desc=" compute the rf_data based on V2 wts and V1 filters";
  };
 };
 step_prog=NULL;
 step_n=1;
};
